# 열거형 (Enums)

열거형을 이용하면 이름이 있는 상수들의 집합을 선언할 수 있습니다.
열거형을 사용하면 명확히 구분되는 사례들의 집합을 만들 수 있으며, 문서를 좀 더 명확하게 작성할 수 있습니다.
타입스크립트에서는 숫자, 문자를 이용하여 열거형 데이터를 만들 수 있습니다.

## 숫자 열거형 (Numeric enums)

다른 언어를 배워 보신 분들이라면 친숙하게 느끼실 수 있는 숫자 열거형에 대해서 먼저 배워보겠습니다.
열거형은 `enum` 이라는 용어를 사용하여 정의할 수 있습니다.

```ts
enum Direction {
    Up = 1,
    Down,
    Left,
    Right,
}
```

위 코드를 이용하여 예시를 들겠습니다.
우리는 Direction이라는 열거형 데이터를 선언하였고, `Up`을 `1` 으로 초기화하여 숫자 열거형을 선언했습니다.
이러면 뒤따르는 멤버들은 자동으로 증가한 값을 갖습니다.
즉 `Direction.Up` 은 `1`,  `Down` 은 `2`, `Left` 는 `3`, `Right` 은 `4` 입니다.

원한다면 아래와 같이 숫자 초기화하는 과정을 완전히 없앨 수도 있습니다.

```ts
enum Direction {
    Up,
    Down,
    Left,
    Right,
}
```

위 경우 `Up` 값은 0입니다. `Down` 은 `1` 이 될 것이며 아까와 마찬가지로 뒤따르는 멤버들은 자동으로 증가하는 값을 같습니다.
이렇게 자동으로 증가하는 기능은 멤버들의 값이 어떤 값인지 신경 쓰지 않아도 되는 경우 굉장히 유용합니다.
하지만 하나의 열거형에 존재하는 각각의 값들이 다른 값들과 명확히 구별될 수 있도록 신경 써야 합니다.

열거형을 사용하는 것은 매우 쉽습니다. 그냥 열거형 그 자체에서 프로퍼티 접근하듯이 아무 멤버에 접근하면 됩니다.
그리고 타입이 필요한 경우 열거형의 이름을 이용하여 사용해주면 됩니다.

```ts
enum Response {
    No = 0,
    Yes = 1,
}

function respond(recipient: string, message: Response): void {
    // ...
}

respond("Princess Caroline", Response.Yes)
```

숫자 열거형은 [계산된 멤버와 상수 멤버](#계산된-멤버와-상수-멤버-computed-and-constant-members)를 섞어서 사용할 수 있습니다.
하지만 섞어서 사용할 경우, 초기화되지 않은 열거형 멤버를 같이 사용할 때는 조심해야 합니다.
초기화되지 않은 열거형 멤버는 계산된 멤버보다 아예 먼저 나오거나, 그 뒤에 나온다면 숫자 상수로 초기화된 멤버 뒤에 나와야 합니다.
즉 아래와 같은 방식으로 사용하는 것은 허용하지 않습니다.

```ts
enum E {
    A = getSomeValue(),
    B, // 에러 : 앞에 나온 A가 계산된 멤버이므로 초기화가 필요합니다.
}
```

* 번역 외 : 아래와 같은 경우 멤버 `C`는 계산된 멤버 `A` 뒤에 나왔지만, 숫자 상수로 초기화된 멤버 `B` 뒤에 나왔기 때문에 에러가 나질 않습니다.

```ts
enum E {
    A = getSomeValue(),
    B = 1,
    C,
}
```

## 문자 열거형 (String enums)

문자 열거형은 유사한 개념이지만 아래 설명된 것과 같이 [런타임에서 열거형](#런타임에서-열거형-enums-at-runtime)의 동작이 약간 다릅니다.
문자 열거형에서 각 멤버들은 문자 리터럴 이거나 다른 문자 열거형의 멤버로 상수 초기화 되어야 합니다.

```ts
enum Direction {
    Up = "UP",
    Down = "DOWN",
    Left = "LEFT",
    Right = "RIGHT",
}
```

문자 열거형은 숫자 열거형처럼 자동 증가하는 기능은 없지만, 직렬화를 매우 잘한다는 이점이 있습니다.
다시 말해서 만약 당신이 숫자 열거형을 이용해서 디버깅하고 있고 그 값을 읽어야 한다면, 종종 그 값이 어떤 의미인지 애매모호 해질 때가 있습니다.
숫자만으로는 이것이 어떤 의미인지 유의미한 정보를 제공해주지 않기 때문입니다. ([역 매핑](#역-매핑-Reverse-mappings) 을 이용하면 도움이 될지라도 말입니다)
반면 문자 열거형을 이용하면 당신이 코드를 실행할 때, 열거형 멤버에 지정된 이름과는 무관하게 유의미하고 읽기 좋은 값을 이용하여 실행할 수 있도록 도와줍니다.

## 이상한 열거형 (Heterogeneous enums)

기술적으로 열거형은 숫자와 문자를 섞어서 사용할 수 있습니다.
하지만 굳이 그렇게 사용해야 할 이유가 전혀 없습니다.

```ts
enum BooleanLikeHeterogeneousEnum {
    No = 0,
    Yes = "YES",
}
```

꼭 정말 이렇게 사용했을 때만 코드가 더 잘 동작하는 게 아니라면, 이렇게 사용하지 않는 것을 권해드립니다.

## 계산된 멤버와 상수 멤버 (Computed and constant members)

각 열거형의 멤버는 상수이거나 계산으로 얻어진 값일 수 있습니다.
열거형의 멤버는 아래의 경우 상수로 간주합니다.

* 열거형의 첫 번째 데이터이며 초기화 값이 없는 경우. 이런 경우 0으로 상수 값이 할당됩니다.

  ```ts
  // E.X는 상수 0입니다.
  enum E { X }
  ```

* 초기화 값이 없으며 숫자 상수로 초기화된 열거형 멤버 뒤에 따라 나오는 경우. 이런 경우 앞에 나온 상수 값에 1씩 증가한 값을 상수로 갖습니다.

  ```ts
  // 'E1' 과 'E2' 의 모든 열거형 멤버는 상수입니다.

  enum E1 { X, Y, Z }

  enum E2 {
      A = 1, B, C
  }
  ```

* 열거형 멤버는 상수 열거형 표현식으로 초기화됩니다.
  상수 열거형 표현식은 컴파일 시 알아낼 수 있는 타입스크립트 표현식의 일부입니다.
  아래의 경우 상수 열거형 표현식이라고 합니다.
    1. 리터럴 열거형 표현식를 사용하는 경우 (기본적으로 문자 리터럴 또는 숫자 리터럴)
    2. 이전에 정의된 다른 상수 열거형 멤버를 참조하는 경우
    3. 괄호로 묶인 상수 열거형인 경우
    4. 상수 열거형 표현식에 단항 연산자 `+`, `-`, `~` 를 사용한 경우
    5. 상수 열거형 표현식을 이중 연산자 `+`, `-`, `*`, `/`, `%`, `<<`, `>>`, `>>>`, `&`, `|`, `^` 의 피연산자로 사용할 경우  

  상수 열거형 표현식 값이 `NaN` 이거나 `Infinity` 이면 컴파일 시점에 에러가 납니다.

이외 다른 모든 경우 열거형 멤버는 계산된 것으로 간주합니다.

```ts
enum FileAccess {
    // 상수 멤버
    None,
    Read    = 1 << 1,
    Write   = 1 << 2,
    ReadWrite  = Read | Write,
    // 계산된 멤버
    G = "123".length
}
```

## 유니언 열거형과 열거형 멤버 타입 (Union enums and enum member types)

계산되지 않은 상수 열거형에는 특별한 부분 집합 리터럴 열거형 멤버가 존재합니다.
리터럴 열거형 멤버는 초기화 값이 존재하지 않거나 아래와 같은 방식으로 초기화된 상수 열거형 멤버입니다.

* 문자 리터럴 (예시. `"foo"`, `"bar`, `"baz"`)
* 숫자 리터럴 (예시. `1`, `100`)
* 숫자 리터럴에 단항 연산자 `-` 가 적용된 경우 (e.g. `-1`, `-100`)

열거형의 모든 멤버가 리터럴 열거형 값을 가지면 특별한 의미로 쓰이게 됩니다.

첫째로 열거형 멤버를 타입처럼 사용할 수 있습니다!
예를 들어 어떤 특정 멤버는 오직 어떤 열거형 멤버 값만 가지게 할 수 있습니다.

```ts
enum ShapeKind {
    Circle,
    Square,
}

interface Circle {
    kind: ShapeKind.Circle;
    radius: number;
}

interface Square {
    kind: ShapeKind.Square;
    sideLength: number;
}

let c: Circle = {
    kind: ShapeKind.Square, // 에러 : 'ShapeKind.Circle' 이 이미 할당되어있기 때문에 'ShapeKind.Square' 을 할당할 수 없습니다.
    radius: 100,
}
```

또 다른 점은 열거형 타입 자체가 효율적으로 각각의 열거형 멤버의 유니언이 된다는 점입니다.
우리가 아직 유니언 타입에 대해서 배우진 않았지만, 유니언 타입 열거형을 사용하면 타입 시스템이 '열거형 자체에 존재하는 정확한 값의 집합을 알고 있다는 사실을 활용할 수 있다는 점'만 알아두면 됩니다.
이러한 이유로 타입스크립트는 우리가 종종 값을 잘못 비교하는 멍청한 실수를 할 때, 버그 잡는 것을 도와줍니다.
예를 들어 :

```ts
enum E {
    Foo,
    Bar,
}

function f(x: E) {
    if (x !== E.Foo || x !== E.Bar) {
        //             ~~~~~~~~~~~
        // 에러! E 타입은 Foo, Bar 둘 중 하나이기 때문에 이 조건은 항상 true를 반환합니다.
    }
}
```

이 예제에서 우리는 `x` 가 `E.Foo` 가 *아닌지* 확인합니다.
만약 이 조건이 true 라면, `||` 조건은 더는 체크할 필요가 없으므로 if 아래의 body가 실행될 것입니다.
그러나 만약 이 조건이 false 라면, `x` 는 반드시 `E.Foo` 입니다.
그렇기 때문에 x가 `E.Bar` 가 아닌지 묻는 조건과 비교하는 것은 반드시 true를 반환하기 때문에 말이 안 됩니다.

## 런타임에서 열거형 (Enums at runtime)

열거형은 런타임에서 실제 객체로 존재합니다.
예를 들어 아래와 같은 열거형은

```ts
enum E {
    X, Y, Z
}
```

사실 아래와 같이 함수로 전달될 수 있습니다.

```ts
function f(obj: { X: number }) {
    return obj.X;
}

// E가 X라는 숫자 프로퍼티를 가지고 있기 때문에 동작하는 코드입니다.
f(E);
```

## 컴파일 시점에서 열거형 (Enums at compile time)

열거형이 런타임에서 실제로는 객체라고 할지라도, `keyof` 문법은 당신이 일반적인 객체에서 기대하는 동작과 다르게 동작합니다. 대신, `keyof typeof` 를 사용하면 모든 열거형의 키를 문자열로 나타내는 타입을 얻어올 수 있습니다.

```ts
enum LogLevel {
    ERROR, WARN, INFO, DEBUG
}

/**
 * 이것은 아래와 동일합니다. :
 * type LogLevelStrings = 'ERROR' | 'WARN' | 'INFO' | 'DEBUG';
 */
type LogLevelStrings = keyof typeof LogLevel;

function printImportant(key: LogLevelStrings, message: string) {
    const num = LogLevel[key];
    if (num <= LogLevel.WARN) {
       console.log('Log level key is: ', key);
       console.log('Log level value is: ', num);
       console.log('Log level message is: ', message);
    }
}
printImportant('ERROR', 'This is a message');
```

### 역 매핑 (Reverse mappings)

멤버를 위해 프로퍼티 이름을 가진 객체를 생성하는 것 이외에도, 숫자 열거형 멤버는 열거형 값에서 열거형 이름으로 가는 *역 매핑* 을 얻게 됩니다.
예를 들어 아래의 예제에서 :

```ts
enum Enum {
    A
}
let a = Enum.A;
let nameOfA = Enum[a]; // "A"
```

타입스크립트는 아마 아래와 같은 자바스크립트 코드로 컴파일할 겁니다.

```js
var Enum;
(function (Enum) {
    Enum[Enum["A"] = 0] = "A";
})(Enum || (Enum = {}));
var a = Enum.A;
var nameOfA = Enum[a]; // "A"
```

이렇게 생성된 코드에서, 열거형은 정방향 (`name` -> `value`) 매핑과 역방향 (`value` -> `name`) 매핑 두 정보를 모두 저장하는 객체로 컴파일됩니다.
다른 열거형 멤버 참조는 항상 프로퍼티 접근으로 방출되며 인라인(inlined) 되지 않습니다.

문자 열거형은 역 매핑을 생성하지 *않는다* 는 것을 명심하시길 바랍니다.

### Const 열거형 (`const` enums)

대부분의 경우, 열거형은 완벽한 해결책입니다.
하지만 종종 열거형의 요구사항이 좀 더 엄격해지길 원할 때가 있습니다.
이때, 즉 불필요하게 추가 생성되는 코드에 시간 낭비하는 것을 피하거나 열거형 값에 우회 접근하는 방법들을 막기 위해 Const 열거형을 사용할 수 있습니다.
Const 열거형은 `const` 를 열거형에 붙여 정의할 수 있습니다.

```ts
const enum Enum {
    A = 1,
    B = A * 2
}
```

Const 열거형은 상수 열거형 표현식만 사용될 수 있습니다.
그리고 일반적인 열거형과 달리 컴파일 과정에서 완전히 삭제됩니다.
Const 열거형은 사용하는 공간에 치환되어 들어갑니다.
이러한 동작은 Const 열거형이 계산된 멤버를 가지고 있지 않기 때문에 가능합니다.

```ts
const enum Directions {
    Up,
    Down,
    Left,
    Right
}

let directions = [Directions.Up, Directions.Down, Directions.Left, Directions.Right]
```

위 코드는 아래와 같이 컴파일됩니다.

```js
var directions = [0 /* Up */, 1 /* Down */, 2 /* Left */, 3 /* Right */];
```

## 앰비언트 열거형 (Ambient enums)

앰비언트 열거형은 이미 존재하는 열거형 타입의 모습을 묘사하기 위해 사용됩니다.

```ts
declare enum Enum {
    A = 1,
    B,
    C = 2
}
```

앰비언트 열거형과 비-앰비언트 열거형의 가장 큰 차이점은 다음과 같습니다.
일반적인 열거형에서 초기화되지 않은 멤버가 상수로 간주하는 멤버 뒤에 있다면, 이 멤버도 상수로 간주할 것입니다.
반면 (const 가 아닌) 앰비언트 열거형에서 초기화되지 않은 멤버는 *항상* 계산된 멤버로 간주합니다.
